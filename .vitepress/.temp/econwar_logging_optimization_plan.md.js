import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"Plan de Optimización del Logging de Eventos","description":"","frontmatter":{},"headers":[],"relativePath":"econwar/logging_optimization_plan.md","filePath":"econwar/logging_optimization_plan.md"}');
const _sfc_main = { name: "econwar/logging_optimization_plan.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="plan-de-optimizacion-del-logging-de-eventos" tabindex="-1">Plan de Optimización del Logging de Eventos <a class="header-anchor" href="#plan-de-optimizacion-del-logging-de-eventos" aria-label="Permalink to &quot;Plan de Optimización del Logging de Eventos&quot;">​</a></h1><h2 id="objetivo" tabindex="-1">Objetivo <a class="header-anchor" href="#objetivo" aria-label="Permalink to &quot;Objetivo&quot;">​</a></h2><p>Optimizar el sistema de logging de eventos para reducir la carga en la base de datos y el uso de almacenamiento, identificando eventos de alta frecuencia cuyo valor informativo puede preservarse con estrategias menos granulares.</p><h2 id="analisis-y-candidatos-para-optimizacion" tabindex="-1">Análisis y Candidatos para Optimización <a class="header-anchor" href="#analisis-y-candidatos-para-optimizacion" aria-label="Permalink to &quot;Análisis y Candidatos para Optimización&quot;">​</a></h2><p>Basado en la revisión del código (<code>scripts/event_logger.gd</code>) y las llamadas a <code>EventLogger.add_event</code>, se identificaron los siguientes tipos de eventos como candidatos para optimización:</p><ol><li><strong><code>PLAYER</code>, &quot;population_growth&quot;:</strong> Potencialmente muy frecuente si se registra por unidad o tick.</li><li><strong><code>RESOURCE</code>, &quot;resource_update&quot;:</strong> El logging basado en umbrales porcentuales puede generar ruido si los valores fluctúan cerca del umbral.</li><li><strong><code>PLAYER</code>, &quot;population_distribution_changed&quot;:</strong> Acciones rápidas del jugador podrían generar múltiples logs seguidos.</li><li>**<code>PLAYER</code>/<code>BATTLE</code>, &quot;expansion_success&quot;<code>/</code>&quot;expansion_failed&quot;<code>:** Posiblemente redundantes si ya existe un evento resumen </code>expansion_completed\`.</li><li><strong>Varios Eventos UI (<code>PLAYER</code>/<code>GAME</code>):</strong> Logs de clics inválidos, informativos (<code>ui_expansion_invalid</code>, <code>ui_territory_info</code>, etc.) pueden ser excesivos y de bajo valor analítico a largo plazo.</li></ol><h2 id="estrategias-de-optimizacion-propuestas" tabindex="-1">Estrategias de Optimización Propuestas <a class="header-anchor" href="#estrategias-de-optimizacion-propuestas" aria-label="Permalink to &quot;Estrategias de Optimización Propuestas&quot;">​</a></h2><ol><li><p><strong>Crecimiento de Población (<code>PLAYER</code>, &quot;population_growth&quot;):</strong></p><ul><li><strong>Estrategia:</strong> Logging por Intervalos.</li><li><strong>Detalle:</strong> Registrar la población total por jugador cada N segundos (ej. 60 segundos) en lugar de cada cambio. Mover la llamada a <code>add_event</code> a una función temporizada.</li><li><strong>Datos Ejemplo:</strong> <code>{ &quot;player_id&quot;: X, &quot;total_population&quot;: Y, &quot;interval_seconds&quot;: 60 }</code></li></ul></li><li><p><strong>Actualización de Recursos (<code>RESOURCE</code>, &quot;resource_update&quot;):</strong></p><ul><li><strong>Estrategia:</strong> Umbral con Cooldown/Debounce o Logging por Intervalos.</li><li><strong>Detalle:</strong> Mantener el umbral porcentual pero añadir un cooldown (ej. 10-30 segundos) después de registrar un evento para ese recurso/jugador. Alternativamente, registrar todos los niveles de recursos para un jugador periódicamente (ej. 30-60 segundos).</li><li><strong>Datos Ejemplo (Intervalo):</strong> <code>{ &quot;player_id&quot;: X, &quot;resources&quot;: { &quot;gold&quot;: G, &quot;food&quot;: F, ... }, &quot;interval_seconds&quot;: 30 }</code></li></ul></li><li><p><strong>Distribución de Población (<code>PLAYER</code>, &quot;population_distribution_changed&quot;):</strong></p><ul><li><strong>Estrategia:</strong> Cooldown/Debounce.</li><li><strong>Detalle:</strong> Añadir un cooldown corto (ej. 5-10 segundos) después de registrar un cambio para el mismo jugador para filtrar ajustes rápidos.</li><li><strong>Datos:</strong> (Mismos datos, menor frecuencia)</li></ul></li><li><p><strong>Éxito/Fallo de Expansión (Individual) (<code>PLAYER</code>/<code>BATTLE</code>, &quot;expansion_success&quot;<code>/</code>&quot;expansion_failed&quot;\`):</strong></p><ul><li><strong>Estrategia:</strong> Consolidar en Resumen.</li><li><strong>Detalle:</strong> Eliminar los logs individuales. Asegurar que el evento resumen <code>expansion_completed</code> contenga toda la información necesaria (resultado, participantes, territorio, bajas, duración, etc.).</li><li><strong>Datos (Resumen - Asegurar):</strong> <code>{ &quot;action&quot;: &quot;expansion_completed&quot;, &quot;success&quot;: true/false, &quot;attacker_id&quot;: A, &quot;defender_id&quot;: D, &quot;territory_id&quot;: T, &quot;duration&quot;: S, &quot;casualties&quot;: { ... }, ... }</code></li></ul></li><li><p><strong>Eventos de UI Menores (<code>PLAYER</code>/<code>GAME</code>):</strong></p><ul><li><strong>Estrategia:</strong> Logging Selectivo / Muestreo / Eliminación.</li><li><strong>Detalle:</strong><ul><li><em>Eliminar</em> logs puramente informativos (<code>ui_territory_info</code>).</li><li><em>Considerar eliminar o muestrear</em> logs de intentos inválidos/cooldowns (<code>ui_expansion_invalid</code>, <code>ui_expansion_cooldown</code>).</li><li><em>Mantener</em> logs de comandos explícitos del usuario (<code>ui_expansion_command</code>).</li></ul></li><li><strong>Datos:</strong> (Eliminar o muestrear eventos existentes)</li></ul></li></ol><h2 id="diagrama-de-flujo-propuesta" tabindex="-1">Diagrama de Flujo (Propuesta) <a class="header-anchor" href="#diagrama-de-flujo-propuesta" aria-label="Permalink to &quot;Diagrama de Flujo (Propuesta)&quot;">​</a></h2><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">graph TD</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    subgraph Current Logging (High Frequency)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        A[Population Unit Change] --&gt; L(Log: population_growth)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        B[Resource Fluctuation] --&gt; L2(Log: resource_update)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        C[Worker Reallocation] --&gt; L3(Log: population_distribution_changed)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        D[Expansion Step Success/Fail] --&gt; L4(Log: expansion_success/failed)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        E[Invalid UI Click] --&gt; L5(Log: ui_expansion_invalid)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        F[Info UI Click] --&gt; L6(Log: ui_territory_info)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    end</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    subgraph Proposed Logging (Optimized)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        G[Timer (e.g., 60s)] --&gt; L_Opt1(Log Summary: population_total)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        H[Resource Change + Cooldown] --&gt; L_Opt2(Log Summary: resource_levels OR Log: resource_update (debounced))</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        I[Worker Reallocation + Cooldown] --&gt; L_Opt3(Log: population_distribution_changed (debounced))</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        J[Expansion End] --&gt; L_Opt4(Log Summary: expansion_completed)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        K[Invalid UI Click] --&gt; R1(REMOVE / SAMPLE Log)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        L[Info UI Click] --&gt; R2(REMOVE Log)</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    end</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    style L fill:#f9f,stroke:#333,stroke-width:2px</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    style L2 fill:#f9f,stroke:#333,stroke-width:2px</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    style L3 fill:#f9f,stroke:#333,stroke-width:2px</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    style L4 fill:#f9f,stroke:#333,stroke-width:2px</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    style L5 fill:#f9f,stroke:#333,stroke-width:2px</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    style L6 fill:#f9f,stroke:#333,stroke-width:2px</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    style L_Opt1 fill:#9cf,stroke:#333,stroke-width:2px</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    style L_Opt2 fill:#9cf,stroke:#333,stroke-width:2px</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    style L_Opt3 fill:#9cf,stroke:#333,stroke-width:2px</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    style L_Opt4 fill:#9cf,stroke:#333,stroke-width:2px</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    style R1 fill:#ccc,stroke:#333,stroke-width:2px</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    style R2 fill:#ccc,stroke:#333,stroke-width:2px</span></span></code></pre></div><h2 id="nota-importante" tabindex="-1">Nota Importante <a class="header-anchor" href="#nota-importante" aria-label="Permalink to &quot;Nota Importante&quot;">​</a></h2><p>Al implementar estos cambios, se debe tener cuidado de modificar únicamente las llamadas a <code>EventLogger.add_event</code> y no afectar las llamadas existentes a <code>DebugConfig.log_game</code> u otros sistemas de logging/debug.</p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("econwar/logging_optimization_plan.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const logging_optimization_plan = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  logging_optimization_plan as default
};
